{"version":3,"sources":["../src/core/scaffolding-module.ts","../src/core/scaffolding-handler.ts","../src/core/scaffolding-config.ts","../src/core/scaffolding-finder.ts","../src/index.ts"],"sourcesContent":["import { debug as _debug } from 'debug';\nimport type { Project } from 'ts-morph';\nimport { z } from 'zod';\n\nimport {\n  type ScaffoldingExecutor,\n  type ScaffoldingModuleAbstract,\n  type ScaffoldingModuleLogger,\n  type ScaffoldingRequest,\n} from './scaffolding.interfaces';\n\nconst debug = _debug('scaffold:module');\n\n/**\n * Define a scaffold module\n *\n * todo, Options are stored in the 'scaffold.lock' file and are available to the module function\n *  at initialization.\n *\n * Based on the options, the module exposes a set of actions and a set of executors to run the actions.\n *\n * The orchestrator will run the actions and executors in the correct order, store the configuration and a journal\n *  of the actions and executors that were run.\n *\n */\nexport class ScaffoldingModule<Schema extends z.ZodObject<any, any, any> = z.ZodObject<any, any, any>>\n  implements ScaffoldingModuleAbstract<Schema>\n{\n  public version: string = '1.0.0';\n  public priority: number = 50;\n  public enabled = true;\n  public configSchema?: Schema;\n\n  constructor(\n    public name?: string,\n    public requests: ScaffoldingRequest[] = [],\n    public executors: ScaffoldingExecutor[] = [],\n  ) {}\n\n  /**\n   * Execute the module requests\n   *  by default, this will execute all the requests, made by this module in order of creation\n   *  when the order is important, or there are additional tasks, you can extend this class\n   *\n   *  ScaffoldingModuleAbstract.exec\n   */\n  public async exec(\n    context: {\n      cwd: string;\n      modules: Record<string, ScaffoldingModuleAbstract<any>>;\n      config: z.infer<Schema>;\n      store: Record<string, any>;\n      arguments: Record<string, any>;\n    },\n    plugins: {\n      tsMorphProject: Project;\n      logger: ScaffoldingModuleLogger;\n    },\n  ) {\n    for await (const request of this.requests) {\n      if (!request.executors || request.executors.length < 1) {\n        continue;\n      }\n      for (const ex of request.executors) {\n        if (!ex.executor.exec) {\n          continue;\n        }\n        debug(\n          `execute ${this.name} -> ${ex.executor.match.module} ${ex.executor.description ? ` -> ${ex.executor.description}` : ''}`,\n        );\n        /**\n         * ScaffoldingExecutor.exec\n         */\n        await ex.executor.exec(\n          {\n            request,\n            state: ex.context.state,\n          },\n          plugins,\n        );\n      }\n    }\n    return {\n      // store\n    };\n  }\n}\n","import { debug as _debug } from 'debug';\nimport { Project } from 'ts-morph';\n\nimport { loadConfig } from './scaffolding-config';\nimport type { ScaffoldingExecutor, ScaffoldingModuleAbstract } from './scaffolding.interfaces';\n\nconst debug = _debug('scaffold:handler');\n\nexport class ScaffoldingHandler {\n  public readonly tsMorphProject;\n  public readonly modulesDict: Record<string, ScaffoldingModuleAbstract<any>> = {};\n  public readonly executors: ScaffoldingExecutor[] = [];\n  public readonly config: Record<string, any> = {};\n\n  public logger(level: 'info' | 'warn' | 'error', message: string, context?: string) {\n    // eslint-disable-next-line no-console\n    console.log(`[${level}] ${context ? `[${context}]` : ''} ${message}`);\n  }\n\n  constructor(\n    //\n    public readonly cwd: string = process.cwd(),\n  ) {\n    this.tsMorphProject = new Project({ tsConfigFilePath: `${cwd}/tsconfig.json` });\n    this.config = loadConfig(this.cwd);\n  }\n\n  register(module: ScaffoldingModuleAbstract<any>) {\n    if (!module.name) {\n      throw new Error('name is required');\n    }\n    if (module.name in this.modulesDict) {\n      throw new Error(`ScaffoldingModule ${module.name} already exists`);\n    }\n    // debug(`register ${module.name}`);\n    this.modulesDict[module.name] = module;\n  }\n\n  /**\n   * Initialize all modules\n   */\n  async init() {\n    // list of all registered modules\n    const modules = Object.values(this.modulesDict);\n\n    // init all modules\n    for (const module of modules) {\n      // load config for the module\n      let config = module.name && module.name in this.config ? this.config[module.name] : undefined;\n      if (module.configSchema) {\n        // validate the config if schema is provided\n        const { success, data, error } = await module.configSchema.safeParseAsync(config || {});\n        if (!success) {\n          throw new Error(`Invalid config for ${module.name}: ${error}`);\n        }\n        config = data;\n      }\n\n      /**\n       * ScaffoldingModuleAbstract.init\n       */\n      if (module.init) {\n        await module.init(\n          {\n            cwd: this.cwd,\n            // todo, pass in config\n            modules: this.modulesDict,\n            config,\n            // todo, pass in persisted store\n            store: {},\n            // todo, pass in run arguments\n            arguments: {},\n          },\n          {\n            tsMorphProject: this.tsMorphProject,\n            // todo, expand logger for more contextual messages\n            logger: this.logger,\n          },\n        );\n        // the module might have disabled itself by setting enabled to false\n      } else {\n        debug(`init* ${module.name}`);\n      }\n    }\n\n    // register all executors\n    for (const module of modules) {\n      this.executors.push(\n        ...module.executors.map((x) => ({\n          // add module to matcher\n          ...x,\n          match: { ...x.match, module: module.name },\n        })),\n      );\n    }\n\n    /**\n     * Initialize all module requests\n     */\n    for (const module of modules) {\n      for (const request of module.requests.filter((x) => Object.keys(x.match).length > 0)) {\n        request.module = module;\n        const requestExecutors: {\n          context: {\n            state?: Record<string, any>;\n          };\n          executor: ScaffoldingExecutor;\n        }[] = [];\n        for await (const exe of this.executors) {\n          if (!exe.match || !Object.entries(request.match).every(([key, value]) => exe.match[key] === value)) {\n            continue;\n          }\n          if (exe.init) {\n            /**\n             * ScaffoldingExecutor.init\n             */\n            const { disabled, state } = await exe.init(\n              {\n                request,\n              },\n              {\n                tsMorphProject: this.tsMorphProject,\n                // todo, expand logger for more contextual messages\n                logger: this.logger,\n              },\n              // stub for response\n              {\n                disabled: false,\n                state: {},\n              },\n            );\n            if (!disabled) {\n              // init executor\n              debug(\n                `init ${module.name}\\t -> ${exe?.match.module} \\t${exe?.description ? ` -> ${exe.description}` : ''}`,\n              );\n              requestExecutors.push({\n                context: {\n                  state,\n                },\n                executor: exe,\n              });\n            }\n          } else {\n            debug(\n              `init* ${module.name}\\t -> ${exe?.match.module} \\t${exe?.description ? ` -> ${exe.description}` : ''}`,\n            );\n            requestExecutors.push({\n              context: {},\n              executor: exe,\n            });\n          }\n        }\n        request.executors = requestExecutors;\n        if (request.executors.length === 0 && !request.optional) {\n          // todo, add more context to the error message\n          throw new Error(\n            `No executors found for ${module.name} ${request.description ? ` -> ${request.description}` : ''}`,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute all modules\n   */\n  async exec() {\n    const modules = Object.values(this.modulesDict)\n      // filter out disabled modules\n      .filter((x) => x.enabled)\n      // order by priority\n      .sort((a, b) => a.priority - b.priority);\n\n    for await (const module of modules) {\n      /**\n       * ScaffoldingModuleAbstract.exec\n       */\n      // const { store } =\n      await module.exec(\n        {\n          cwd: this.cwd,\n          modules: this.modulesDict,\n          config: {}, // todo, pass in config\n          store: {}, // todo pass in persisted store\n          arguments: {}, // todo, pass in run arguments\n        },\n        {\n          tsMorphProject: this.tsMorphProject,\n          // todo, expand logger for more contextual messages\n          logger: this.logger,\n        },\n      );\n      // todo, persist the returned store\n    }\n\n    // apply code changes\n    await this.tsMorphProject.save();\n  }\n\n  /**\n   * De-register all modules\n   */\n  reset() {\n    for (const key in this.modulesDict) {\n      delete this.modulesDict[key];\n    }\n  }\n}\n","import { cosmiconfigSync } from 'cosmiconfig';\nimport { debug as _debug } from 'debug';\n\nconst debug = _debug('scaffold:config');\n\nexport function loadConfig(cwd: string): Record<string, any> {\n  const explorer = cosmiconfigSync('scaffold', {\n    stopDir: cwd,\n    searchPlaces: [\n      `.scaffold/scaffold.config.json`,\n      `.scaffold/scaffold.config.yaml`,\n      `.scaffold/scaffold.config.yml`,\n      `.scaffold/scaffold.config.js`,\n      `.scaffold/scaffold.config.ts`,\n      `.scaffold/scaffold.config.cjs`,\n      `scaffold.config.json`,\n      `scaffold.config.yaml`,\n      `scaffold.config.yml`,\n      `scaffold.config.js`,\n      `scaffold.config.ts`,\n      `scaffold.config.cjs`,\n    ],\n    mergeSearchPlaces: false,\n  });\n  const result = explorer.search(cwd);\n  if (!result || result.isEmpty) {\n    debug(`no config found`);\n    return {};\n  }\n  debug(`using ${result.filepath}`);\n  return result.config;\n}\n","import { debug as _debug } from 'debug';\nimport { glob } from 'fast-glob';\nimport { jsVariants } from 'interpret';\nimport { extname } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { prepare } from 'rechoir';\n\nimport type { ScaffoldingModule } from './scaffolding-module';\n\nconst debug = _debug('scaffold:finder');\n\n/**\n * Import or require a module\n *  this allows for runtime .ts support\n * @see https://github.com/webpack/webpack-cli/blob/e480934116ec190d915e83fef8e2d945717963cb/packages/webpack-cli/src/webpack-cli.ts#L327\n */\nasync function tryRequireThenImport(module: string): Promise<any> {\n  let result;\n  try {\n    result = require(module);\n  } catch (error: any) {\n    let importEsm: ((module: string) => Promise<{ default: any }>) | undefined;\n    try {\n      importEsm = new Function('id', 'return import(id);') as any;\n    } catch (e) {\n      importEsm = undefined;\n    }\n    if (error.code === 'ERR_REQUIRE_ESM' && importEsm) {\n      const urlForConfig = pathToFileURL(module).href;\n      result = (await importEsm(urlForConfig)).default;\n      return result;\n    }\n    throw error;\n  }\n  // For babel/typescript\n  if (result && typeof result === 'object' && 'default' in result) result = result.default || {};\n  return result || {};\n}\n\n/**\n * Load a module from a file path\n * @see https://github.com/webpack/webpack-cli/blob/e480934116ec190d915e83fef8e2d945717963cb/packages/webpack-cli/src/webpack-cli.ts#L1717\n */\nexport async function loadModule(path: string): Promise<any> {\n  const ext = extname(path);\n  if (ext === '.json' || !Object.keys(jsVariants).includes(ext)) {\n    throw new Error(`Unsupported file type: ${ext}`);\n  }\n  prepare(jsVariants, path);\n  return await tryRequireThenImport(path);\n}\n\nexport async function* findScaffoldFiles<SM extends ScaffoldingModule>(context: { cwd: string }): AsyncGenerator<SM> {\n  for (const file of await glob(['**/.*.scaffold.*', '**/.scaffold.*'], {\n    cwd: context.cwd,\n    dot: true, // allow dot files\n    ignore: ['node_modules'],\n  })) {\n    debug(`found ${file}`);\n    try {\n      yield await loadModule(`${context.cwd}/${file}`);\n    } catch (error) {\n      // todo messages\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n}\n","export { ScaffoldingModule } from './core/scaffolding-module';\nexport {\n  type ScaffoldingModuleAbstract,\n  type ScaffoldingExecutor,\n  type ScaffoldingRequest,\n  type ScaffoldingModuleLogger,\n} from './core/scaffolding.interfaces';\n\nexport { ScaffoldingHandler } from './core/scaffolding-handler';\nexport { findScaffoldFiles } from './core/scaffolding-finder';\n\n/**\n * Plugins commonly used in scaffolding\n *  export them to enforce consistent usage\n */\nexport * as tsMorph from 'ts-morph';\nexport * as semver from 'semver';\nexport * as zod from 'zod';\n"],"mappings":"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","names":["debug","_debug","debug","_debug","ScaffoldingModule","version","priority","enabled","configSchema","constructor","name","requests","executors","exec","context","plugins","request","length","ex","executor","match","module","description","state","debug","_debug","Project","cosmiconfigSync","debug","_debug","debug","_debug","loadConfig","cwd","explorer","cosmiconfigSync","stopDir","searchPlaces","mergeSearchPlaces","result","search","isEmpty","filepath","config","debug","_debug","ScaffoldingHandler","tsMorphProject","modulesDict","executors","config","logger","level","message","context","console","log","constructor","cwd","process","Project","tsConfigFilePath","loadConfig","register","module","name","Error","init","modules","Object","values","undefined","configSchema","success","data","error","safeParseAsync","store","arguments","push","map","x","match","request","requests","filter","keys","length","requestExecutors","exe","entries","every","key","value","disabled","state","description","executor","optional","exec","enabled","sort","a","b","priority","save","reset","debug","_debug","glob","jsVariants","extname","pathToFileURL","prepare","debug","_debug","tryRequireThenImport","module","result","require","error","importEsm","Function","e","undefined","code","urlForConfig","pathToFileURL","href","default","loadModule","path","ext","extname","Object","keys","jsVariants","includes","Error","prepare","findScaffoldFiles","context","file","glob","cwd","dot","ignore","console","tsMorph","semver","zod"]}