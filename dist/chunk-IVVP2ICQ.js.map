{"version":3,"sources":["../src/core/scaffolding-module.ts","../src/core/scaffolding-handler.ts","../src/core/scaffolding-config.ts","../src/core/scaffolding-finder.ts","../src/index.ts"],"names":["debug","_debug","ScaffoldingModule","version","priority","enabled","configSchema","constructor","name","requests","executors","exec","context","plugins","request","length","ex","executor","match","module","description","state","Project","cosmiconfigSync","loadConfig","cwd","explorer","stopDir","searchPlaces","mergeSearchPlaces","result","search","isEmpty","filepath","config","ScaffoldingHandler","tsMorphProject","modulesDict","logger","level","message","console","log","process","tsConfigFilePath","register","Error","init","modules","Object","values","undefined","success","data","error","safeParseAsync","store","arguments","push","map","x","filter","keys","requestExecutors","exe","entries","every","key","value","disabled","optional","sort","a","b","save","reset","glob","jsVariants","extname","pathToFileURL","prepare","tryRequireThenImport","require","importEsm","Function","e","code","urlForConfig","href","default","loadModule","path","ext","includes","findScaffoldFiles","file","dot","ignore","tsMorph","semver","zod"],"mappings":"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","sourcesContent":["import { debug as _debug } from 'debug';\nimport type { Project } from 'ts-morph';\nimport { z } from 'zod';\n\nimport {\n  type ScaffoldingExecutor,\n  type ScaffoldingModuleAbstract,\n  type ScaffoldingModuleLogger,\n  type ScaffoldingRequest,\n} from './scaffolding.interfaces';\n\nconst debug = _debug('scaffold:module');\n\n/**\n * Define a scaffold module\n *\n * todo, Options are stored in the 'scaffold.lock' file and are available to the module function\n *  at initialization.\n *\n * Based on the options, the module exposes a set of actions and a set of executors to run the actions.\n *\n * The orchestrator will run the actions and executors in the correct order, store the configuration and a journal\n *  of the actions and executors that were run.\n *\n */\nexport class ScaffoldingModule<Schema extends z.ZodObject<any, any, any> = z.ZodObject<any, any, any>>\n  implements ScaffoldingModuleAbstract<Schema>\n{\n  public version: string = '1.0.0';\n  public priority: number = 50;\n  public enabled = true;\n  public configSchema?: Schema;\n\n  constructor(\n    public name?: string,\n    public requests: ScaffoldingRequest[] = [],\n    public executors: ScaffoldingExecutor[] = [],\n  ) {}\n\n  /**\n   * Execute the module requests\n   *  by default, this will execute all the requests, made by this module in order of creation\n   *  when the order is important, or there are additional tasks, you can extend this class\n   *\n   *  ScaffoldingModuleAbstract.exec\n   */\n  public async exec(\n    context: {\n      cwd: string;\n      modules: Record<string, ScaffoldingModuleAbstract<any>>;\n      config: z.infer<Schema>;\n      store: Record<string, any>;\n      arguments: Record<string, any>;\n    },\n    plugins: {\n      tsMorphProject: Project;\n      logger: ScaffoldingModuleLogger;\n    },\n  ) {\n    for await (const request of this.requests) {\n      if (!request.executors || request.executors.length < 1) {\n        continue;\n      }\n      for (const ex of request.executors) {\n        if (!ex.executor.exec) {\n          continue;\n        }\n        debug(\n          `execute ${this.name} -> ${ex.executor.match.module} ${ex.executor.description ? ` -> ${ex.executor.description}` : ''}`,\n        );\n        /**\n         * ScaffoldingExecutor.exec\n         */\n        await ex.executor.exec(\n          {\n            request,\n            state: ex.context.state,\n          },\n          plugins,\n        );\n      }\n    }\n    return {\n      // store\n    };\n  }\n}\n","import { debug as _debug } from 'debug';\nimport { Project } from 'ts-morph';\n\nimport { loadConfig } from './scaffolding-config';\nimport type { ScaffoldingExecutor, ScaffoldingModuleAbstract } from './scaffolding.interfaces';\n\nconst debug = _debug('scaffold:handler');\n\nexport class ScaffoldingHandler {\n  public readonly tsMorphProject;\n  public readonly modulesDict: Record<string, ScaffoldingModuleAbstract<any>> = {};\n  public readonly executors: ScaffoldingExecutor[] = [];\n  public readonly config: Record<string, any> = {};\n\n  public logger(level: 'info' | 'warn' | 'error', message: string, context?: string) {\n    // eslint-disable-next-line no-console\n    console.log(`[${level}] ${context ? `[${context}]` : ''} ${message}`);\n  }\n\n  constructor(\n    //\n    public readonly cwd: string = process.cwd(),\n  ) {\n    this.tsMorphProject = new Project({ tsConfigFilePath: `${cwd}/tsconfig.json` });\n    this.config = loadConfig(this.cwd);\n  }\n\n  register(module: ScaffoldingModuleAbstract<any>) {\n    if (!module.name) {\n      throw new Error('name is required');\n    }\n    if (module.name in this.modulesDict) {\n      throw new Error(`ScaffoldingModule ${module.name} already exists`);\n    }\n    // debug(`register ${module.name}`);\n    this.modulesDict[module.name] = module;\n  }\n\n  /**\n   * Initialize all modules\n   */\n  async init() {\n    // list of all registered modules\n    const modules = Object.values(this.modulesDict);\n\n    // init all modules\n    for (const module of modules) {\n      // load config for the module\n      let config = module.name && module.name in this.config ? this.config[module.name] : undefined;\n      if (module.configSchema) {\n        // validate the config if schema is provided\n        const { success, data, error } = await module.configSchema.safeParseAsync(config || {});\n        if (!success) {\n          throw new Error(`Invalid config for ${module.name}: ${error}`);\n        }\n        config = data;\n      }\n\n      /**\n       * ScaffoldingModuleAbstract.init\n       */\n      if (module.init) {\n        await module.init(\n          {\n            cwd: this.cwd,\n            // todo, pass in config\n            modules: this.modulesDict,\n            config,\n            // todo, pass in persisted store\n            store: {},\n            // todo, pass in run arguments\n            arguments: {},\n          },\n          {\n            tsMorphProject: this.tsMorphProject,\n            // todo, expand logger for more contextual messages\n            logger: this.logger,\n          },\n        );\n        // the module might have disabled itself by setting enabled to false\n      } else {\n        debug(`init* ${module.name}`);\n      }\n    }\n\n    // register all executors\n    for (const module of modules) {\n      this.executors.push(\n        ...module.executors.map((x) => ({\n          // add module to matcher\n          ...x,\n          match: { ...x.match, module: module.name },\n        })),\n      );\n    }\n\n    /**\n     * Initialize all module requests\n     */\n    for (const module of modules) {\n      for (const request of module.requests.filter((x) => Object.keys(x.match).length > 0)) {\n        request.module = module;\n        const requestExecutors: {\n          context: {\n            state?: Record<string, any>;\n          };\n          executor: ScaffoldingExecutor;\n        }[] = [];\n        for await (const exe of this.executors) {\n          if (!exe.match || !Object.entries(request.match).every(([key, value]) => exe.match[key] === value)) {\n            continue;\n          }\n          if (exe.init) {\n            /**\n             * ScaffoldingExecutor.init\n             */\n            const { disabled, state } = await exe.init(\n              {\n                request,\n              },\n              {\n                tsMorphProject: this.tsMorphProject,\n                // todo, expand logger for more contextual messages\n                logger: this.logger,\n              },\n              // stub for response\n              {\n                disabled: false,\n                state: {},\n              },\n            );\n            if (!disabled) {\n              // init executor\n              debug(\n                `init ${module.name}\\t -> ${exe?.match.module} \\t${exe?.description ? ` -> ${exe.description}` : ''}`,\n              );\n              requestExecutors.push({\n                context: {\n                  state,\n                },\n                executor: exe,\n              });\n            }\n          } else {\n            debug(\n              `init* ${module.name}\\t -> ${exe?.match.module} \\t${exe?.description ? ` -> ${exe.description}` : ''}`,\n            );\n            requestExecutors.push({\n              context: {},\n              executor: exe,\n            });\n          }\n        }\n        request.executors = requestExecutors;\n        if (request.executors.length === 0 && !request.optional) {\n          // todo, add more context to the error message\n          throw new Error(\n            `No executors found for ${module.name} ${request.description ? ` -> ${request.description}` : ''}`,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute all modules\n   */\n  async exec() {\n    const modules = Object.values(this.modulesDict)\n      // filter out disabled modules\n      .filter((x) => x.enabled)\n      // order by priority\n      .sort((a, b) => a.priority - b.priority);\n\n    for await (const module of modules) {\n      /**\n       * ScaffoldingModuleAbstract.exec\n       */\n      // const { store } =\n      await module.exec(\n        {\n          cwd: this.cwd,\n          modules: this.modulesDict,\n          config: {}, // todo, pass in config\n          store: {}, // todo pass in persisted store\n          arguments: {}, // todo, pass in run arguments\n        },\n        {\n          tsMorphProject: this.tsMorphProject,\n          // todo, expand logger for more contextual messages\n          logger: this.logger,\n        },\n      );\n      // todo, persist the returned store\n    }\n\n    // apply code changes\n    await this.tsMorphProject.save();\n  }\n\n  /**\n   * De-register all modules\n   */\n  reset() {\n    for (const key in this.modulesDict) {\n      delete this.modulesDict[key];\n    }\n  }\n}\n","import { cosmiconfigSync } from 'cosmiconfig';\nimport { debug as _debug } from 'debug';\n\nconst debug = _debug('scaffold:config');\n\nexport function loadConfig(cwd: string): Record<string, any> {\n  const explorer = cosmiconfigSync('scaffold', {\n    stopDir: cwd,\n    searchPlaces: [\n      `.scaffold/scaffold.config.json`,\n      `.scaffold/scaffold.config.yaml`,\n      `.scaffold/scaffold.config.yml`,\n      `.scaffold/scaffold.config.js`,\n      `.scaffold/scaffold.config.ts`,\n      `.scaffold/scaffold.config.cjs`,\n      `scaffold.config.json`,\n      `scaffold.config.yaml`,\n      `scaffold.config.yml`,\n      `scaffold.config.js`,\n      `scaffold.config.ts`,\n      `scaffold.config.cjs`,\n    ],\n    mergeSearchPlaces: false,\n  });\n  const result = explorer.search(cwd);\n  if (!result || result.isEmpty) {\n    debug(`no config found`);\n    return {};\n  }\n  debug(`using ${result.filepath}`);\n  return result.config;\n}\n","import { debug as _debug } from 'debug';\nimport { glob } from 'fast-glob';\nimport { jsVariants } from 'interpret';\nimport { extname } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { prepare } from 'rechoir';\n\nimport type { ScaffoldingModule } from './scaffolding-module';\n\nconst debug = _debug('scaffold:finder');\n\n/**\n * Import or require a module\n *  this allows for runtime .ts support\n * @see https://github.com/webpack/webpack-cli/blob/e480934116ec190d915e83fef8e2d945717963cb/packages/webpack-cli/src/webpack-cli.ts#L327\n */\nasync function tryRequireThenImport(module: string): Promise<any> {\n  let result;\n  try {\n    result = require(module);\n  } catch (error: any) {\n    let importEsm: ((module: string) => Promise<{ default: any }>) | undefined;\n    try {\n      importEsm = new Function('id', 'return import(id);') as any;\n    } catch (e) {\n      importEsm = undefined;\n    }\n    if (error.code === 'ERR_REQUIRE_ESM' && importEsm) {\n      const urlForConfig = pathToFileURL(module).href;\n      result = (await importEsm(urlForConfig)).default;\n      return result;\n    }\n    throw error;\n  }\n  // For babel/typescript\n  if (result && typeof result === 'object' && 'default' in result) result = result.default || {};\n  return result || {};\n}\n\n/**\n * Load a module from a file path\n * @see https://github.com/webpack/webpack-cli/blob/e480934116ec190d915e83fef8e2d945717963cb/packages/webpack-cli/src/webpack-cli.ts#L1717\n */\nexport async function loadModule(path: string): Promise<any> {\n  const ext = extname(path);\n  if (ext === '.json' || !Object.keys(jsVariants).includes(ext)) {\n    throw new Error(`Unsupported file type: ${ext}`);\n  }\n  prepare(jsVariants, path);\n  return await tryRequireThenImport(path);\n}\n\nexport async function* findScaffoldFiles<SM extends ScaffoldingModule>(context: { cwd: string }): AsyncGenerator<SM> {\n  for (const file of await glob(['**/.*.scaffold.*', '**/.scaffold.*'], {\n    cwd: context.cwd,\n    dot: true, // allow dot files\n    ignore: ['node_modules'],\n  })) {\n    debug(`found ${file}`);\n    try {\n      yield await loadModule(`${context.cwd}/${file}`);\n    } catch (error) {\n      // todo messages\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n}\n","export { ScaffoldingModule } from './core/scaffolding-module';\nexport {\n  type ScaffoldingModuleAbstract,\n  type ScaffoldingExecutor,\n  type ScaffoldingRequest,\n  type ScaffoldingModuleLogger,\n} from './core/scaffolding.interfaces';\n\nexport { ScaffoldingHandler } from './core/scaffolding-handler';\nexport { findScaffoldFiles } from './core/scaffolding-finder';\n\n/**\n * Plugins commonly used in scaffolding\n *  export them to enforce consistent usage\n */\nexport * as tsMorph from 'ts-morph';\nexport * as semver from 'semver';\nexport * as zod from 'zod';\n"]}