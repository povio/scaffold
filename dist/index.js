"use strict";var a=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var $=Object.getOwnPropertyNames;var b=Object.prototype.hasOwnProperty;var o=(r,t)=>a(r,"name",{value:t,configurable:!0});var C=(r,t)=>{for(var s in t)a(r,s,{get:t[s],enumerable:!0})},S=(r,t,s,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of $(t))!b.call(r,i)&&i!==s&&a(r,i,{get:()=>t[i],enumerable:!(e=j(t,i))||e.enumerable});return r};var R=r=>S(a({},"__esModule",{value:!0}),r);var I={};C(I,{Handler:()=>f,createScaffolding:()=>E,findScaffoldFiles:()=>M});module.exports=R(I);var y=require("ts-morph");var w=require("cosmiconfig"),x=require("debug");var m=(0,x.debug)("scaffold:config");function p(r){let s=(0,w.cosmiconfigSync)("scaffold",{stopDir:r,searchPlaces:[".scaffold/scaffold.config.json",".scaffold/scaffold.config.yaml",".scaffold/scaffold.config.yml",".scaffold/scaffold.config.js",".scaffold/scaffold.config.ts",".scaffold/scaffold.config.cjs","scaffold.config.json","scaffold.config.yaml","scaffold.config.yml","scaffold.config.js","scaffold.config.ts","scaffold.config.cjs"],mergeSearchPlaces:!1}).search(r);return!s||s.isEmpty?(m("no config found"),{}):(m(`using ${s.filepath}`),s.config)}o(p,"loadConfig");var h=class{static{o(this,"Module")}handler;constructor(t,s){this.handler=s,this._status="uninitialized",this.name=t.name,this.version=t.version??"1.0.0",this.description=t.description,this.messages=[],this._init=t.init,this.tasks=[],this.configSchema=t.configSchema,this.config=t.config,this._requests=t.requests??[],this._executors=t.executors??[],this.requests=[],this.executors=[],this.handler.onEvent("register",this,t)}get id(){return this.name}name;version;description;_status;get status(){return this._status}set status(t){this._status=t,this.handler.onEvent("status",this,t)}messages;addMessage(t,s,e){let i={type:t,message:s,error:e,status:this.status};return this.messages.push(i),this.handler.onEvent("message",this,i),i}_requests;_executors;requests;executors;tasks;configSchema;config;async initConfig(t){if(this.configSchema){let{success:s,data:e,error:i}=await this.configSchema.safeParseAsync(t||{});if(!s)throw new Error(`Invalid config for ${this.name}: ${i}`);this.config=e,this.handler.onEvent("configure",this,t)}}async runInit(t,s){if(this.status!=="uninitialized")throw new Error("Module has already been initialized");let e={...s,addMessage:(...i)=>this.addMessage(...i),setStatus:i=>{this.status=i}};try{this._executors&&await Promise.all(this._executors.map(e.addExecutor)),this._requests&&await Promise.all(this._requests.map(e.addRequest)),this._init&&await this._init(t,e)}catch(i){this.addMessage("error","Error while initializing module",i),this.status="error"}this.status==="uninitialized"&&(this.status=this.requests.length<1&&this.executors.length<1?"disabled":"queued")}_init},u=class{static{o(this,"Request")}handler;constructor(t,s,e){this.handler=e,this._status="uninitialized",this.description=t.description,this.match=t.match,this.value=t.value,this.optional=t.optional??!1,this.priority=t.priority??0,this.messages=[],this.tasks=[],this.module=t.module??s,s.requests.push(this),this.id=e.makeId(`${this.module.id}:request`),this.handler.onEvent("register",this,t)}id;module;description;match;value;optional;priority;_status;get status(){return this._status}set status(t){this._status=t,this.handler.onEvent("status",this,t)}addMessage(t,s,e){let i={type:t,message:s,error:e,status:this.status};return this.messages.push(i),this.handler.onEvent("message",this,i),i}messages;tasks},c=class{static{o(this,"Executor")}module;handler;constructor(t,s,e){this.module=s,this.handler=e,this.status="registered",this.module=s,this.description=t.description,this.match=t.match,this.priority=t.priority??0,this.exception=t.exception??"ignore",this._exec=t.exec,this._init=t.init,this.module.executors.push(this),this.id=e.makeId(`${this.module.id}:executor`),this.handler.onEvent("register",this)}id;description;match;priority;get init(){return this._init}_init;exception;get exec(){return this._exec}status;_exec},d=class{static{o(this,"Task")}handler;executor;request;constructor(t,s,e,i){this.handler=s,this.executor=e,this.request=i,this._status="uninitialized",this.messages=[],this.priority=e.priority+i.priority/1e3,this.request.module.tasks.push(this),this.id=s.makeId(`${this.request.module.id}->${this.executor.id}->task`),this.handler.onEvent("register",this)}id;async runInit(t){if(this.executor.init)try{await this.executor.init(this,{...t,addMessage:this.addMessage})}catch(s){if(this.status="error",this.addMessage("error","Error while task init",s),this.executor.exception==="throw")throw s}this.status=this.executor.exec?"queued":"completed"}async runExec(t){if(!this.executor.exec)throw new Error("No exec function defined");try{await this.executor.exec(this,{...t,addMessage:this.addMessage}),this.status==="queued"&&(this.status="completed")}catch(s){if(this.status="error",this.addMessage("error","Error while task exec",s),this.executor.exception==="throw")throw s}}_status;get status(){return this._status}set status(t){this._status=t,this.handler.onEvent("status",this,t)}messages;addMessage(t,s,e){let i={type:t,message:s,error:e,status:this.status};return this.messages.push(i),this.handler.onEvent("message",this,i),i}priority;data};var f=class{static{o(this,"Handler")}cwd;onEvent;modulesDict;rawConfig;executors;requestQueue;tasks;tsMorphProject;_status;constructor(t=process.cwd(),s=()=>{}){this.cwd=t,this.onEvent=s,this.modulesDict={},this.rawConfig={},this.executors=[],this.requestQueue=[],this.tasks=[],this._status="uninitialized",this.ids={},this.tsMorphProject=new y.Project({tsConfigFilePath:`${t}/tsconfig.json`}),this.rawConfig=p(this.cwd),this.status="registered"}register(t){if(!t.name||t.name in this.modulesDict)throw new Error(`Can not register module "${t.name??"[missing name]"}"`);return this.modulesDict[t.name]=new h(t,this),t}async registerRequest(t,s){let e=new u(t,s,this);return this.requestQueue.push(e),this.requestQueue.sort((i,l)=>i.priority-l.priority),e}async registerExecutor(t,s){if(!["loading-executors"].includes(this.status))throw new Error("Cannot add executor outside of module init");let e=new c(t,s,this);return this.executors.push(e),e}async initTasks(t){if(!["loading-tasks"].includes(this.status))throw new Error("Cannot init request outside of task loading step");t.description||(t.description=t.match);let s=this.executors.filter(e=>e.match===t.match);if(s.length<1)return t.optional?t.status="disabled":(t.status="error",t.addMessage("error",`No executors found for request ${t.match}`)),t;for(let e of s){let i=new d({},this,e,t);await i.runInit({withTsMorph:async l=>{await l({project:this.tsMorphProject})}}),i.status==="queued"&&this.tasks.push(i)}return t.status="queued",t}set status(t){this._status=t,this.onEvent("status",this,t)}get status(){return this._status}async init(){this.status="loading-configs";for(let t of Object.values(this.modulesDict))await t.initConfig(t.name in this.rawConfig?this.rawConfig[t.name]:{});this.status="loading-executors";for(let t of Object.values(this.modulesDict))await t.runInit({cwd:this.cwd,modules:this.modulesDict,config:t.config},{addRequest:s=>this.registerRequest(s,t),addExecutor:s=>this.registerExecutor(s,t)});for(let t of this.executors.filter(s=>s.match.endsWith(":#before-all")||s.match.endsWith(":#after-all")))await this.registerRequest({description:`run ${t.match.endsWith(":#before-all")?"before":"after"} for ${t.module.name}`,match:t.match},t.module);for(this.status="loading-tasks";this.requestQueue.length>0;)await this.initTasks(this.requestQueue.shift());if(this.requestQueue.length>0)throw new Error("Request queue was not emptied");if(Object.values(this.modulesDict).some(t=>t.status==="uninitialized"))throw new Error("Modules were not initialized");if(Object.values(this.modulesDict).some(t=>t.requests.some(s=>s.status==="uninitialized")))throw new Error("Requests were not initialized");this.status=this.tasks.length>0?"queued":"completed"}async exec(){this.status="executing";let t=this.tasks.toSorted((s,e)=>s.priority-e.priority);for(;t.length>0;){let s=t.shift();if(s?.status!=="queued")throw new Error("Task is not queued");s.runExec({withTsMorph:async e=>{await e({project:this.tsMorphProject})}})}await this.tsMorphProject.save(),this.status="executed"}ids;makeId(t){return this.ids[t]||(this.ids[t]=0),`${t}#${this.ids[t]++}`}get id(){return"handler"}};function E(r){return r}o(E,"createScaffolding");var _=require("fast-glob"),g=require("interpret"),q=require("path"),k=require("url"),v=require("rechoir");async function z(r){let t;try{t=require(r)}catch(s){let e;try{e=new Function("id","return import(id);")}catch{e=void 0}if(s.code==="ERR_REQUIRE_ESM"&&e){let i=(0,k.pathToFileURL)(r).href;return t=(await e(i)).default,t}throw s}return t&&typeof t=="object"&&"default"in t&&(t=t.default||{}),t||{}}o(z,"tryRequireThenImport");async function P(r){let t=(0,q.extname)(r);if(t===".json"||!Object.keys(g.jsVariants).includes(t))throw new Error(`Unsupported file type: ${t}`);return(0,v.prepare)(g.jsVariants,r),await z(r)}o(P,"loadModule");async function*M(r){for(let t of await(0,_.glob)(["**/.*.scaffold.*","**/.scaffold.*"],{cwd:r.cwd,dot:!0,ignore:["node_modules"]}))try{yield await P(`${r.cwd}/${t}`)}catch(s){console.error(s)}}o(M,"findScaffoldFiles");0&&(module.exports={Handler,createScaffolding,findScaffoldFiles});
