"use strict";var _=Object.create;var f=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var R=Object.getOwnPropertyNames;var O=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var c=(r,o)=>f(r,"name",{value:o,configurable:!0});var I=(r,o)=>{for(var e in o)f(r,e,{get:o[e],enumerable:!0})},p=(r,o,e,t)=>{if(o&&typeof o=="object"||typeof o=="function")for(let s of R(o))!k.call(r,s)&&s!==e&&f(r,s,{get:()=>o[s],enumerable:!(t=F(o,s))||t.enumerable});return r};var a=(r,o,e)=>(e=r!=null?_(O(r)):{},p(o||!r||!r.__esModule?f(e,"default",{value:r,enumerable:!0}):e,r)),U=r=>p(f({},"__esModule",{value:!0}),r);var L={};I(L,{ScaffoldingHandler:()=>u,ScaffoldingModule:()=>d,YAWN:()=>Y,findScaffoldFiles:()=>S,glob:()=>v.glob,semver:()=>V,tsMorph:()=>Q,zod:()=>W});module.exports=U(L);var x=require("debug");var A=(0,x.debug)("scaffold:module"),d=class{static{c(this,"ScaffoldingModule")}name;requests;executors;version;priority;enabled;configSchema;constructor(o,e=[],t=[]){this.name=o,this.requests=e,this.executors=t,this.version="1.0.0",this.priority=50,this.enabled=!0}async exec(o,e){for await(let t of this.requests)if(!(!t.executors||t.executors.length<1))for(let s of t.executors)s.executor.exec&&(A(`execute ${this.name} -> ${s.executor.match.module} ${s.executor.description?` -> ${s.executor.description}`:""}`),await s.executor.exec({request:t,state:s.context.state},e));return{}}};var j=require("debug"),P=require("ts-morph");var y=require("cosmiconfig"),$=require("debug");var w=(0,$.debug)("scaffold:config");function b(r){let e=(0,y.cosmiconfigSync)("scaffold",{stopDir:r,searchPlaces:[".scaffold/scaffold.config.json",".scaffold/scaffold.config.yaml",".scaffold/scaffold.config.yml",".scaffold/scaffold.config.js",".scaffold/scaffold.config.ts",".scaffold/scaffold.config.cjs","scaffold.config.json","scaffold.config.yaml","scaffold.config.yml","scaffold.config.js","scaffold.config.ts","scaffold.config.cjs"],mergeSearchPlaces:!1}).search(r);return!e||e.isEmpty?(w("no config found"),{}):(w(`using ${e.filepath}`),e.config)}c(b,"loadConfig");var h=(0,j.debug)("scaffold:handler"),u=class{static{c(this,"ScaffoldingHandler")}cwd;tsMorphProject;modulesDict;executors;rawConfig;config;logger(o,e,t){console.log(`[${o}] ${t?`[${t}]`:""} ${e}`)}constructor(o=process.cwd()){this.cwd=o,this.modulesDict={},this.executors=[],this.rawConfig={},this.config={},this.tsMorphProject=new P.Project({tsConfigFilePath:`${o}/tsconfig.json`}),this.rawConfig=b(this.cwd)}register(o){if(!o.name)throw new Error("name is required");if(o.name in this.modulesDict)throw new Error(`ScaffoldingModule ${o.name} already exists`);this.modulesDict[o.name]=o}async init(){let o=Object.values(this.modulesDict);for(let e of o){let t=e.name in this.rawConfig?this.rawConfig[e.name]:void 0;if(e.configSchema){let{success:s,data:i,error:n}=await e.configSchema.safeParseAsync(t||{});if(!s)throw new Error(`Invalid config for ${e.name}: ${n}`);t=i}this.config[e.name]=t,e.init?await e.init({cwd:this.cwd,modules:this.modulesDict,config:t,store:{},arguments:{}},{tsMorphProject:this.tsMorphProject,logger:this.logger}):h(`init* ${e.name}`)}for(let e of o)this.executors.push(...e.executors.map(t=>({...t,match:{...t.match,module:e.name}})));for(let e of o)for(let t of e.requests.filter(s=>Object.keys(s.match).length>0)){t.module=e;let s=[];for await(let i of this.executors)if(!(!i.match||!Object.entries(t.match).every(([n,m])=>i.match[n]===m)))if(i.init){let{disabled:n,state:m}=await i.init({request:t},{tsMorphProject:this.tsMorphProject,logger:this.logger},{disabled:!1,state:{}});n||(h(`init ${e.name}	 -> ${i?.match.module} 	${i?.description?` -> ${i.description}`:""}`),s.push({context:{state:m},executor:i}))}else h(`init* ${e.name}	 -> ${i?.match.module} 	${i?.description?` -> ${i.description}`:""}`),s.push({context:{},executor:i});if(t.executors=s,t.executors.length===0&&!t.optional)throw new Error(`No executors found for ${e.name} ${t.description?` -> ${t.description}`:""}`)}}async exec(){let o=Object.values(this.modulesDict).filter(e=>e.enabled).sort((e,t)=>e.priority-t.priority);for await(let e of o)await e.exec({cwd:this.cwd,modules:this.modulesDict,config:this.config[e.name],store:{},arguments:{}},{tsMorphProject:this.tsMorphProject,logger:this.logger});await this.tsMorphProject.save()}reset(){for(let o in this.modulesDict)delete this.modulesDict[o]}};var M=require("debug"),E=require("fast-glob"),g=require("interpret"),D=require("path"),q=require("url"),C=require("rechoir");var N=(0,M.debug)("scaffold:finder");async function T(r){let o;try{o=require(r)}catch(e){let t;try{t=new Function("id","return import(id);")}catch{t=void 0}if(e.code==="ERR_REQUIRE_ESM"&&t){let s=(0,q.pathToFileURL)(r).href;return o=(await t(s)).default,o}throw e}return o&&typeof o=="object"&&"default"in o&&(o=o.default||{}),o||{}}c(T,"tryRequireThenImport");async function z(r){let o=(0,D.extname)(r);if(o===".json"||!Object.keys(g.jsVariants).includes(o))throw new Error(`Unsupported file type: ${o}`);return(0,C.prepare)(g.jsVariants,r),await T(r)}c(z,"loadModule");async function*S(r){for(let o of await(0,E.glob)(["**/.*.scaffold.*","**/.scaffold.*"],{cwd:r.cwd,dot:!0,ignore:["node_modules"]})){N(`found ${o}`);try{yield await z(`${r.cwd}/${o}`)}catch(e){console.error(e)}}}c(S,"findScaffoldFiles");var Q=a(require("ts-morph")),V=a(require("semver")),W=a(require("zod")),v=require("fast-glob"),Y=a(require("yawn-yaml"));0&&(module.exports={ScaffoldingHandler,ScaffoldingModule,YAWN,findScaffoldFiles,glob,semver,tsMorph,zod});
