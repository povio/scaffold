var $=Object.defineProperty;var c=(s,o)=>$(s,"name",{value:o,configurable:!0}),h=(s=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(s,{get:(o,e)=>(typeof require<"u"?require:o)[e]}):s)(function(s){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+s+'" is not supported')});import{debug as y}from"debug";var g=y("scaffold:module"),u=class{static{c(this,"ScaffoldingModule")}name;requests;executors;version;priority;enabled;configSchema;config;constructor(o,e=[],t=[]){this.name=o,this.requests=e,this.executors=t,this.version="1.0.0",this.priority=50,this.enabled=!0}async exec(o,e){for await(let t of this.requests){if(!t.executors||t.executors.length<1){g(`no executors on ${this.name} for request ${t.description||JSON.stringify(t.match)}`);continue}for(let r of t.executors)!r.executor.exec||r.disabled||(g(`execute ${this.name} -> ${r.executor.match.module} ${r.executor.description?` -> ${r.executor.description}`:""}`),await r.executor.exec({request:t,state:r.context.state},e))}return{}}};import{debug as P}from"debug";import{Project as M}from"ts-morph";import{cosmiconfigSync as b}from"cosmiconfig";import{debug as j}from"debug";var p=j("scaffold:config");function x(s){let e=b("scaffold",{stopDir:s,searchPlaces:[".scaffold/scaffold.config.json",".scaffold/scaffold.config.yaml",".scaffold/scaffold.config.yml",".scaffold/scaffold.config.js",".scaffold/scaffold.config.ts",".scaffold/scaffold.config.cjs","scaffold.config.json","scaffold.config.yaml","scaffold.config.yml","scaffold.config.js","scaffold.config.ts","scaffold.config.cjs"],mergeSearchPlaces:!1}).search(s);return!e||e.isEmpty?(p("no config found"),{}):(p(`using ${e.filepath}`),e.config)}c(x,"loadConfig");var f=P("scaffold:handler"),m=class{static{c(this,"ScaffoldingHandler")}cwd;tsMorphProject;modulesDict;executors;rawConfig;config;logger(o,e,t){console.log(`[${o}] ${t?`[${t}]`:""} ${e}`)}constructor(o=process.cwd()){this.cwd=o,this.modulesDict={},this.executors=[],this.rawConfig={},this.config={},this.tsMorphProject=new M({tsConfigFilePath:`${o}/tsconfig.json`}),this.rawConfig=x(this.cwd)}register(o){if(!o.name)throw new Error("name is required");if(o.name in this.modulesDict)throw new Error(`ScaffoldingModule ${o.name} already exists`);this.modulesDict[o.name]=o}async init(){let o=Object.values(this.modulesDict);for(let e of o){let t=e.name in this.rawConfig?this.rawConfig[e.name]:void 0;if(e.configSchema){let{success:r,data:i,error:n}=await e.configSchema.safeParseAsync(t||{});if(!r)throw new Error(`Invalid config for ${e.name}: ${n}`);t=i}this.config[e.name]=t,e.config=t}for(let e of o)e.init?(f(`init ${e.name}`),await e.init({cwd:this.cwd,modules:this.modulesDict,config:this.config[e.name]||{},store:{},arguments:{}},{tsMorphProject:this.tsMorphProject,logger:this.logger})):f(`init* ${e.name}`);for(let e of o)this.executors.push(...e.executors.map(t=>({...t,match:{...t.match,module:e.name}})));for(let e of o)for(let t of e.requests.filter(r=>Object.keys(r.match).length>0)){t.module=e;let r=[];for await(let i of this.executors)if(!(!i.match||!Object.entries(t.match).every(([n,l])=>i.match[n]===l)))if(i.init){let{disabled:n,state:l}=await i.init({request:t},{tsMorphProject:this.tsMorphProject,logger:this.logger},{disabled:!1,state:{}});f(n?`disabled ${e.name}	 -> ${i?.match.module} 	${i?.description?` -> ${i.description}`:""}`:`init ${e.name}	 -> ${i?.match.module} 	${i?.description?` -> ${i.description}`:""}`),r.push({disabled:!!n,context:{state:l},executor:i})}else f(`init* ${e.name}	 -> ${i?.match.module} 	${i?.description?` -> ${i.description}`:""}`),r.push({disabled:!1,context:{},executor:i});if(t.executors=r,t.executors.length===0&&!t.optional)throw new Error(`No executors found for ${e.name} ${t.description?` -> ${t.description}`:""}`)}}async exec(){let o=Object.values(this.modulesDict).filter(e=>e.enabled).sort((e,t)=>e.priority-t.priority);for await(let e of o)await e.exec({cwd:this.cwd,modules:this.modulesDict,config:this.config[e.name],store:{},arguments:{}},{tsMorphProject:this.tsMorphProject,logger:this.logger});await this.tsMorphProject.save()}reset(){for(let o in this.modulesDict)delete this.modulesDict[o]}};import{debug as E}from"debug";import{glob as q}from"fast-glob";import{jsVariants as w}from"interpret";import{extname as D}from"node:path";import{pathToFileURL as S}from"node:url";import{prepare as C}from"rechoir";var oe=E("scaffold:finder");async function v(s){let o;try{o=h(s)}catch(e){let t;try{t=new Function("id","return import(id);")}catch{t=void 0}if(e.code==="ERR_REQUIRE_ESM"&&t){let r=S(s).href;return o=(await t(r)).default,o}throw e}return o&&typeof o=="object"&&"default"in o&&(o=o.default||{}),o||{}}c(v,"tryRequireThenImport");async function _(s){let o=D(s);if(o===".json"||!Object.keys(w).includes(o))throw new Error(`Unsupported file type: ${o}`);return C(w,s),await v(s)}c(_,"loadModule");async function*F(s){for(let o of await q(["**/.*.scaffold.*","**/.scaffold.*"],{cwd:s.cwd,dot:!0,ignore:["node_modules"]}))try{yield await _(`${s.cwd}/${o}`)}catch(e){console.error(e)}}c(F,"findScaffoldFiles");import*as de from"ts-morph";import*as le from"semver";import*as ue from"zod";import{glob as he}from"fast-glob";import*as ge from"yawn-yaml";export{m as ScaffoldingHandler,u as ScaffoldingModule,ge as YAWN,F as findScaffoldFiles,he as glob,le as semver,de as tsMorph,ue as zod};
